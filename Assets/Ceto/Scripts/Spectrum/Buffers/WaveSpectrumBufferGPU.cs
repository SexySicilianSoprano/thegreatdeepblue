using UnityEngine;
using System;
using System.Collections.Generic;

using Ceto.Common.Unity.Utility;

namespace Ceto
{

    /// <summary>
    /// A buffer that uses FFT on the GPU to transform
    /// the spectrum. The type of data produced depends on the
    /// initialization material used.
    /// </summary>
	public class WaveSpectrumBufferGPU : WaveSpectrumBuffer
	{

        /// <summary>
        /// Holds the actual buffer data.
        /// </summary>
		struct Buffer
		{
            //Array to hold the read/write data
			public RenderTexture[] data;
			public bool disabled;
		}

        /// <summary>
        /// Has the data requested been created.
        /// GPU buffers always create their data 
        /// as soon as requested so this is always true.
        /// </summary>
		public override bool Done { get { return true; } }

        /// <summary>
        /// The fourier size of the buffer.
        /// </summary>
		public override int Size { get { return m_fourier.size; } }

        /// <summary>
        /// Does this buffer run on the GPU. Always true.
        /// </summary>
		public override bool IsGPU { get { return true; } }

        /// <summary>
        /// Used to initialize the buffer before the FFT runs.
        /// The initialization will decide what type of data 
        /// is created, ie displacements, slope, etc.
        /// </summary>
		Material m_initMat;

        /// <summary>
        /// The buffers generated by this object.
        /// </summary>
		Buffer[] m_buffers;

        /// <summary>
        /// If sampling is still enabled.
        /// </summary>
		bool m_samplingEnabled;

        /// <summary>
        /// Current read index.
        /// </summary>
		int m_index = -1;

        /// <summary>
        /// Does the actual FFT on the GPU.
        /// </summary>
		FourierGPU m_fourier;

        /// <summary>
        /// WTable.
        /// </summary>
		Texture2D m_wtable;

        /// <summary>
        /// A list of the currently enabled data.
        /// </summary>
        IList<RenderTexture[]> m_enabledData;

        /// <summary>
        /// A name for the buffers to help when profiling
        /// </summary>
        string m_bufferName;

        public WaveSpectrumBufferGPU(int size, Shader initSdr, Shader fourierSdr, int numBuffers)
		{

			if(numBuffers < 1 || numBuffers > 4)
				throw new InvalidOperationException("Number of buffers is " + numBuffers + " but must be between (inclusive) 1 and 4");
		
			m_initMat = new Material(initSdr);

			m_buffers = new Buffer[numBuffers];

			m_fourier = new FourierGPU(size, fourierSdr);

			for(int i = 0; i < numBuffers; i++)
			{
				m_buffers[i] = CreateBuffer(size);
			}

            m_bufferName = Ocean.InstanceName + " Wave Spectrum GPU Buffer";

            Vector4 offset = Offset(size);
			Vector4 inverseGridSizes = InverseGridSizes(size);

			m_wtable = new Texture2D(size, size, TextureFormat.RGBAFloat, false, true);
			m_wtable.filterMode = FilterMode.Point;
			m_wtable.wrapMode = TextureWrapMode.Clamp;
            m_wtable.hideFlags = HideFlags.HideAndDontSave;
            m_wtable.name = Ocean.InstanceName + " Wave Spectrum GPU wtable";

            m_wtable.SetPixels(CreateWTable(size, inverseGridSizes));
			m_wtable.Apply();

			m_initMat.SetTexture("Ceto_WTable", m_wtable);
			m_initMat.SetVector("Ceto_Offset", offset);
			m_initMat.SetVector("Ceto_InverseGridSizes", inverseGridSizes);

		}

        /// <summary>
        /// Create a buffer for this fourier size.
        /// A buffer requires two textures.
        /// During the FFT one texture is written into  
        /// while the other is read from and then they swap.
        /// This is the read/write method (also know as ping/pong).
        /// </summary>
		Buffer CreateBuffer(int size)
		{

			Buffer buffer = new Buffer();

			buffer.data = new RenderTexture[2];

//			for(int i = 0; i < 2; i++)
//			{
//				buffer.data[i] = new RenderTexture(size, size, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
//				buffer.data[i].filterMode = FilterMode.Point;
//				buffer.data[i].wrapMode = TextureWrapMode.Clamp;
//				buffer.data[i].useMipMap = false;
//				buffer.data[i].anisoLevel = 0;
//				buffer.data[i].hideFlags = HideFlags.HideAndDontSave;
//				buffer.data[i].Create();
//			}

			return buffer;

		}

        /// <summary>
        /// Get the read texture at this idx.
        /// If buffer is disabled or not a valid index
        /// a blank texture is returned.
        /// </summary>
		public override Texture GetTexture(int idx)
		{
			if(m_index == -1) return Texture2D.blackTexture;

			if(idx < 0 || idx >= m_buffers.Length) return Texture2D.blackTexture;

			if(m_buffers[idx].disabled) return Texture2D.blackTexture;

			return m_buffers[idx].data[m_index];
		}

        /// <summary>
        /// Release the buffers.
        /// </summary>
		public override void Release()
		{

            m_fourier.Release();

            int count = m_buffers.Length;
            for (int i = 0; i < count; i++)
            {
				RTUtility.ReleaseAndDestroy(m_buffers[i].data);
                m_buffers[i].data[0] = null;
                m_buffers[i].data[1] = null;
            }

            UnityEngine.Object.Destroy(m_wtable);

		}

        /// <summary>
        /// Initialize the enabled buffers with the current conditions spectrum for this time.
        /// </summary>
		protected override void Initilize(WaveSpectrumCondition condition, float time)
		{

			m_initMat.SetTexture("Ceto_Spectrum01", condition.Spectrum01);
			m_initMat.SetTexture("Ceto_Spectrum23", condition.Spectrum23);
			m_initMat.SetFloat("Ceto_Time", time);

			IList<RenderTexture> tmp = new List<RenderTexture>();

            int count = m_buffers.Length;
            for (int i = 0; i < count; i++)
            {
				if(!m_buffers[i].disabled)
					tmp.Add(m_buffers[i].data[1]);
			}

			if(tmp.Count == 0) return;
			
			RTUtility.MultiTargetBlit(tmp, m_initMat);

		}

        /// <summary>
        /// Gets the data for the buffer at this idx.
        /// If idx is -1 all the buffers will be returned.
        /// Will only ever return enabled buffers.
        /// </summary>
		public IList<RenderTexture[]> GetData(int idx)
		{

			IList<RenderTexture[]> data = new List<RenderTexture[]>();

            //Not valid, return a empty buffer.
            int count = m_buffers.Length;
            if (idx < -1 || idx >= m_buffers.Length) return data;
			
			if(idx == -1)
			{
                //Return all enabled buffer.
                for (int i = 0; i < count; i++)
                {
					if(!m_buffers[i].disabled)
						data.Add(m_buffers[i].data);
				}
			}
			else
			{
                //Return buffer at idx if enabled.
				if(!m_buffers[idx].disabled)
					data.Add(m_buffers[idx].data);
			}

			return data;
			
		}

        /// <summary>
        /// Enables the data for the buffer at this idx.
        /// If idx is -1 all the buffers will be enabled.
        /// </summary>
		public override void EnableBuffer(int idx)
		{

            int count = m_buffers.Length;
            if (idx < -1 || idx >= count) return;
			
			if(idx == -1)
			{
				for(int i = 0; i < count; i++)
				{
					m_buffers[i].disabled = false;
				}
			}
			else
			{
				m_buffers[idx].disabled = false;
			}

            m_enabledData = GetData(-1);

        }

        /// <summary>
        /// Disables the data for the buffer at this idx.
        /// If idx is -1 all the buffers will be disabled.
        /// </summary>
		public override void DisableBuffer(int idx)
		{

            int count = m_buffers.Length;
            if (idx < -1 || idx >= count) return;
			
			if(idx == -1)
			{
				for(int i = 0; i < count; i++)
				{
					m_buffers[i].disabled = true;
				}
			}
			else
			{
				m_buffers[idx].disabled = true;
			}

            m_enabledData = GetData(-1);

        }

        /// <summary>
        /// Returns the number of enabled buffers.
        /// </summary>
		public override int EnabledBuffers()
		{

            if (m_enabledData == null)
                m_enabledData = GetData(-1);

            return m_enabledData.Count;
		}

        /// <summary>
        /// Is this buffer enabled.
        /// </summary>
        public override bool IsEnabledBuffer(int idx)
        {
            if (idx < 0 || idx >= m_buffers.Length) return false;

            return !m_buffers[idx].disabled;

        }

        /// <summary>
        /// Fill the buffer with temporary render textures.
        /// </summary>
        void CreateTextures(IList<RenderTexture[]> buffers)
        {

            for (int i = 0; i < buffers.Count; i++)
            {
                for (int j = 0; j < 2; j++)
                {
                    if (buffers[i][j] != null)
                        RenderTexture.ReleaseTemporary(buffers[i][j]);

                    RenderTexture tex = RenderTexture.GetTemporary(Size, Size, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear);
                    tex.filterMode = FilterMode.Point;
                    tex.wrapMode = TextureWrapMode.Clamp;
                    tex.name = m_bufferName;
                    tex.anisoLevel = 0;
                    tex.Create();

                    buffers[i][j] = tex;
                }
            }
        }

        /// <summary>
        /// Creates the data for this conditions spectrum for this time value.
        /// </summary>
		public override void Run(WaveSpectrumCondition condition, float time)
		{

			TimeValue = time;
			HasRun = true;
			BeenSampled = false;

			if(m_samplingEnabled)
				throw new InvalidOperationException("Can not run if sampling enabled");

            //Get all the buffers data.
            if (m_enabledData == null)
                m_enabledData = GetData(-1);

            CreateTextures(m_enabledData);

            //There are no buffers enabled return.
			int count = m_enabledData.Count;
			if(count == 0) return;

            //Initilize buffers.
			Initilize(condition, time);

            //Perform the FFT. Supports running the FFT on 1-4 buffers at one.
			if(count == 1)
			{
				m_index = m_fourier.PeformFFT(m_enabledData[0]);
			}
			else if(count == 2)
			{
				m_index = m_fourier.PeformFFT(m_enabledData[0], m_enabledData[1]);
			}
			else if(count == 3)
			{
				m_index = m_fourier.PeformFFT(m_enabledData[0], m_enabledData[1], m_enabledData[2]);
			}
			else if(count == 4)
			{
				m_index = m_fourier.PeformFFT(m_enabledData[0], m_enabledData[1], m_enabledData[2], m_enabledData[3]);
			}

		}

        /// <summary>
        /// For the FFT the data must be in point/clamp mode
        /// but to sample the data it needs to be in bilinear/repeat mode.
        /// Change to bilinear/repeat here. Only changes the read buffer.
        /// </summary>
		public override void EnableSampling()
		{

			if(m_index == -1) return;

			m_samplingEnabled = true;

            int count = m_buffers.Length;
            for (int i = 0; i < count; i++)
            {
				if(m_buffers[i].data[m_index] == null) continue;

                m_buffers[i].data[m_index].filterMode = FilterMode.Bilinear;
                m_buffers[i].data[m_index].wrapMode = TextureWrapMode.Repeat;

			}
		}

        /// <summary>
        /// For the FFT the data must be in point/clamp mode
        /// but to sample the data it needs to be in bilinear/repeat mode.
        /// Change to point/clamp here. Only changes the read buffer.
        /// </summary>
		public override void DisableSampling()
		{

			if(m_index == -1) return;

			m_samplingEnabled = false;

            int count = m_buffers.Length;
            for (int i = 0; i < count; i++)
            {
				if(m_buffers[i].data[m_index] == null) continue;

                m_buffers[i].data[m_index].filterMode = FilterMode.Point;
                m_buffers[i].data[m_index].wrapMode = TextureWrapMode.Clamp;
				
			}
		}

	

	}

}







